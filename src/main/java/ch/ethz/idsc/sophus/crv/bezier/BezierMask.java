// code by jph
package ch.ethz.idsc.sophus.crv.bezier;

import ch.ethz.idsc.tensor.RationalScalar;
import ch.ethz.idsc.tensor.RealScalar;
import ch.ethz.idsc.tensor.Scalar;
import ch.ethz.idsc.tensor.Tensor;
import ch.ethz.idsc.tensor.Tensors;
import ch.ethz.idsc.tensor.alg.Binomial;
import ch.ethz.idsc.tensor.api.ScalarTensorFunction;
import ch.ethz.idsc.tensor.red.Times;
import ch.ethz.idsc.tensor.sca.Power;

/** evaluation of Bernstein polynomials */
public class BezierMask implements ScalarTensorFunction {
  /** @param n
   * @return */
  public static ScalarTensorFunction of(int n) {
    return new BezierMask(n);
  }

  /** The weight mask is generated by the following formula
   * <pre>
   * With[{p = n / (n - 1)}, Table[Binomial[n - 1, k] (1 - p)^(n - k - 1) p^k, {k, 0, n - 1}]]
   * </pre>
   * 
   * The leading coefficient converges to
   * <pre>
   * Limit[(n/(n - 1))^(n - 1), n -> Infinity] == Exp[1]
   * </pre>
   * 
   * @param n
   * @return weight mask of length n with entries that sum up to 1 */
  public static Tensor extrapolate(int n) {
    Scalar p = RationalScalar.of(n, n - 1);
    return of(n).apply(p);
  }

  /***************************************************/
  private final int n;
  private final Binomial binomial;

  private BezierMask(int n) {
    this.n = n;
    binomial = Binomial.of(n - 1);
  }

  /** @param p in the unit interval [0, 1]
   * @param n
   * @return vector of length n with entries that sum up to 1 */
  @Override
  public Tensor apply(Scalar p) {
    Scalar o_p = RealScalar.ONE.subtract(p);
    return Tensors.vector(k -> Times.of(binomial.over(k), Power.of(o_p, n - k - 1), Power.of(p, k)), n);
  }
}
