// code by jph
package ch.alpine.sophus.crv;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.io.IOException;

import org.junit.jupiter.api.Test;

import ch.alpine.sophus.lie.rn.RnGroup;
import ch.alpine.tensor.RationalScalar;
import ch.alpine.tensor.RealScalar;
import ch.alpine.tensor.Scalar;
import ch.alpine.tensor.Tensor;
import ch.alpine.tensor.Tensors;
import ch.alpine.tensor.alg.Range;
import ch.alpine.tensor.api.ScalarTensorFunction;
import ch.alpine.tensor.chq.ExactTensorQ;
import ch.alpine.tensor.ext.Integers;
import ch.alpine.tensor.ext.Serialization;
import ch.alpine.tensor.itp.BernsteinBasis;
import ch.alpine.tensor.mat.IdentityMatrix;
import ch.alpine.tensor.pdf.Distribution;
import ch.alpine.tensor.pdf.PDF;
import ch.alpine.tensor.pdf.d.BinomialDistribution;
import ch.alpine.tensor.red.Total;

class BezierMaskTest {
  /** The weight mask is generated by the following formula
   * <pre>
   * With[{p = n / (n - 1)}, Table[Binomial[n - 1, k] (1 - p)^(n - k - 1) p^k, {k, 0, n - 1}]]
   * </pre>
   * 
   * The leading coefficient converges to
   * <pre>
   * Limit[(n/(n - 1))^(n - 1), n -> Infinity] == Exp[1]
   * </pre>
   * 
   * @param n
   * @return weight mask of length n with entries that sum up to 1 */
  public static Tensor extrapolate(int n) {
    int nm1 = Integers.requirePositive(n) - 1;
    Scalar p = RationalScalar.of(n, nm1);
    return BernsteinBasis.of(nm1, p);
  }

  /** @param n positive
   * @return vector of length n */
  public static ScalarTensorFunction of(int n) {
    int nm1 = Integers.requirePositive(n) - 1;
    return p -> BernsteinBasis.of(nm1, p);
  }

  @Test
  public void testSimple1() {
    assertEquals(BezierMaskTest.of(1).apply(RealScalar.of(0.2)), Tensors.vector(1));
  }

  @Test
  public void testSimple2() throws ClassNotFoundException, IOException {
    ScalarTensorFunction scalarTensorFunction = Serialization.copy(BezierMaskTest.of(2));
    assertEquals(scalarTensorFunction.apply(RationalScalar.HALF), Tensors.fromString("{1/2, 1/2}"));
    assertEquals(scalarTensorFunction.apply(RealScalar.of(0)), Tensors.fromString("{1, 0}"));
    assertEquals(scalarTensorFunction.apply(RealScalar.of(1)), Tensors.fromString("{0, 1}"));
  }

  @Test
  public void testSimple3() {
    ScalarTensorFunction scalarTensorFunction = BezierMaskTest.of(3);
    assertEquals(scalarTensorFunction.apply(RationalScalar.HALF), Tensors.fromString("{1/4, 1/2, 1/4}"));
    assertEquals(scalarTensorFunction.apply(RealScalar.of(0)), Tensors.fromString("{1, 0, 0}"));
    assertEquals(scalarTensorFunction.apply(RealScalar.of(1)), Tensors.fromString("{0, 0, 1}"));
  }

  @Test
  public void testDistribution() {
    for (int n = 5; n < 10; ++n)
      for (Scalar p : new Scalar[] { RationalScalar.of(1, 3), RationalScalar.of(6, 7) }) {
        Tensor vector = BezierMaskTest.of(n).apply(p);
        Distribution distribution = BinomialDistribution.of(n - 1, p);
        PDF pdf = PDF.of(distribution);
        Tensor cmp = Range.of(0, n).map(pdf::at);
        assertEquals(vector, cmp);
        ExactTensorQ.require(vector);
        ExactTensorQ.require(cmp);
      }
  }

  @Test
  public void testFunctionMatch() {
    int n = 5;
    ScalarTensorFunction scalarTensorFunction = BezierFunction.of(RnGroup.INSTANCE, IdentityMatrix.of(n));
    Scalar p = RationalScalar.of(2, 7);
    Tensor vector = scalarTensorFunction.apply(p);
    Tensor weight = BezierMaskTest.of(n).apply(p);
    ExactTensorQ.require(weight);
    ExactTensorQ.require(vector);
    assertEquals(weight, vector);
  }

  @Test
  public void testExtrapolate() {
    assertEquals(BezierMaskTest.extrapolate(2), Tensors.fromString("{-1, 2}"));
    assertEquals(BezierMaskTest.extrapolate(3), Tensors.fromString("{1/4, -3/2, 9/4}"));
    assertEquals(BezierMaskTest.extrapolate(4), Tensors.fromString("{-1/27, 4/9, -16/9, 64/27}"));
    for (int n = 2; n < 10; ++n) {
      Tensor mask = BezierMaskTest.extrapolate(n);
      assertEquals(Total.of(mask), RealScalar.ONE);
      ExactTensorQ.require(mask);
    }
  }

  @Test
  public void testNegFail() {
    assertThrows(Exception.class, () -> BezierMaskTest.of(0));
    assertThrows(Exception.class, () -> BezierMaskTest.of(-1));
  }
}
